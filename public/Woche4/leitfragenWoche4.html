<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Leitfragen Woche 4</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC"
      crossorigin="anonymous"
    />
    <style>
      .mono {
        font-family: monospace;
      }

      li,
      pre {
        margin: 0.5em;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Leitfragen Woche 4</h1>
        <p>
          Die Leitfragen sind ein Einstiegspunkt um das Material zu erschließen.
          Es ist <strong>nicht</strong>
          ausreichend als Vorbereitung zur Klausur die Fragen zu beantworten!
        </p>
        <p></p>
      </header>
      <main>
        <section>
            <h2>Muster</h2>
            <ol>
                <li>Warum sind künstliche Identitäten oft besser als natürliche Identitäten?
                    <p class="antwort">Antwort: Bei natürlichen Identitäten ist nicht immer garantiert, dass diese sich nie mehr ändern werden.
                    Weiterhin kriegen wir künstliche Identitäten unter unsere Kontrolle und können diese durch das Objekt selbst erzeugen lassen.</p>
                </li>
                <li>Entitäten sind dadurch gekennzeichnet, dass sie sich über die Zeit hinweg ändern können. Angenommen
                    jemand behauptet, dass auch Entitäten <strong>immer</strong> als unveränderliche Objekte umgesetzt
                    können. Stimmt das?
                    <p class="antwort">Antwort: Entitäten zeichnen sich unter anderem dadurch aus, dass sie einen Lebenszyklus haben:
                    Sie werden kreiert und verschwinden wieder. Insofern macht es sowieso für kaum bis keine Kontexte Sinn, unveränderliche
                    Objekte als Entities umzusetzen.</p>
                </li>
                <li>Wieso müssen wir die <span class="mono">hashCode</span> Methode immer überschreiben, wenn wir <span
                        class="mono">equals</span> überschrieben? Gilt das eigentlich auch umgekehrt?
                    <p class="antwort"> Antwort: Das gleichzeitige Überschreiben von hashCode()  und equals()
                    gewährleistet das richtige Funktionieren von HashMaps und HashSets etc. Wird in einem HashSet das in dem definierten Attribut
                    gleiche Objekt reingeschrieben (also gibt die überschriebene equals()-Methode true zurück) erkennt das HashSet
                    trotzdem nicht, dass diese Objekte gleich sind => das HashSet funktioniert nicht. </p>
                </li>
                <li>Vergleichen Sie statische Factory Methoden, Konstruktoren und Builder. Welche Gemeinsamkeiten und
                    welche Unterschiede können Sie identifizieren?
                    <p class="antwort">Antwort: Statische Factory-Methoden und Builder kapseln die Konstruktion eines Objekts. Der Unterschied ist jedoch,
                    dass Builder-Klassen für die Integrität der Eigenschaften des Objekts sorgen (und somit die Logik dahinter kapseln) während statische
                    Factory-Methoden dies nicht tun. Statische Factory-Methoden haben den Vorteil, dass sie, im Gegensatz zu Konstruktoren, aufgerufen werden können,
                    ohne vorher ein Objekt der Klasse zu haben.</p>
                </li>
                <li>
                    Wir haben folgenden Record gegeben, der ein Wertobjekt umsetzen soll. Was muss für die Klassen <span
                        class="mono">Strasse</span>, <span class="mono">Postleitzahl</span> und <span
                        class="mono">Stadt</span> gelten?
                    <pre>
public record Adresse(Strasse strasse, Postleitzahl plz, Stadt stadt) {}
                    </pre>
                    <p class="antwort">Antwort: Die Objekte müssen final sein. Außerdem: Da Wertobjekte keine Identität haben, müssen die Tupel aus Straße, PLZ und Stadt eindeutig unterscheidbar sein.
                    Wenn es zwei Orte mit gleichem Stadtnamen, PLZ und Straßennamen gäbe, würde es zu Problemen kommen, da die beiden Objekte im Sinne eines Wertobjekts identisch wären.
                    Dies wird in diesem Fall hauptsächlich durch die Postleitzahl verhindert.</p>

                </li>
                <li>Eine Regel für Aggregate lautet "Es sind nur Referenzen auf die Wurzel-Entität gestattet". Was folgt
                    daraus, wenn wir eine Methode auf einer Entität aufrufen wollen, die innerhalb des Aggregats (also
                    nicht der Root) ist?
                    <p class="antwort">Antwort: </p>
                </li>
            </ol>
        </section>

        <section>
          <h2>Onion Architektur</h2>
          <ol>
            <li>
              Studieren Sie den Code aus dem Projekt
              <span class="mono">zwiebelbuch</span> im Detail. Sie sollten ganz
              genau verstehen, wie die Verdrahtung der Dependencies funktioniert
              und bei jeder Klasse verstehen welche Abhängigkeiten sie hat und
              warum sie in der entsprechenden Schicht ist.
              <p class="antwort">Antwort:</p>
            </li>
            <li>
              Wir haben für Buch und Kapitel jeweils ein korrespondierendes DTO
              (Data Transfer Object). Warum haben wir kein DTO für den Status?
              Oder haben wir vielleicht doch ein DTO?
              <p class="antwort">Antwort:</p>
            </li>
            <li>
              Der nächste Geschäftsfall, den wir benötigen, ist die Freigabe
              eines Kapitels durch das Lektorat. Implementieren Sie den
              Geschäftsfall in der Anwendung. Das HTMl können Sie einfach von
              Hand schreiben und notwendige Werte fest verdrahten.
              <p class="antwort">Antwort:</p>
            </li>
            <li>
              Verwenden Sie nun eine echte Datenbank zum Speichern und laden der
              Aggregate.
              <p class="antwort">Antwort:</p>
            </li>
          </ol>
        </section>

        <section>
          <h2>Offene Fragen</h2>
          <p>
            Notieren Sie, wenn Sie bei der Bearbeitung des Stoffs etwas nicht
            verstanden haben.
          </p>
          <ul>
            <li>...</li>
            <li>...</li>
            <li>...</li>
          </ul>
        </section>
      </main>
    </div>
  </body>
</html>
